# Daham Menu Manager PRD 및 상세 기능 사양서 (버전 5.0)

이 문서는 **Daham Menu Manager 1.0**의 최종 기획서로, 단체 급식용 식단 관리 프로그램의 요구사항을 정의합니다. 이전 버전(4.0)과 엑셀 데이터(0814_도시락.xlsx 등)를 기반으로 하며, 사용자 피드백(약점 대책: 수율 입력, `updated_at`, 지시사항 필드, 식수 정리, UI 단순화)을 반영했습니다. 초보자도 이해할 수 있도록 상세히 설명하고, 계층 구조(식단표 → 세부식단표 → 단일 식단표 → 메뉴 → 레시피 → 식재료 → 단위/소요량)와 식수/수율 계산을 명확히 정리했습니다. 버전 5.0은 개발 시작을 위한 최종 확정본입니다.

---

### 참고 web page http://bok2.boksili.kr/
 현재쓰고 있는 프로그램을 업그레이드 하는 차원의 개발이며, 대부분의 기능중 상당수가 유사해도됨.

## 1. PRD (Product Requirements Document)

### 1.1 프로젝트 개요
- **프로젝트 이름**: Daham Menu Manager 1.0 (다함 식단 프로그램).
- **버전**: 5.0 (최종, 2025.08.25).
- **목적**: 기존 식단 관리 프로그램 개선. 영양사의 메뉴 편성 효율화(복사/수정 중심), 발주 자동화, 지시서 생성 강화. 단체 급식 타겟으로 상용화 가능(SaaS).
- **배경**: 
  - 단체 급식(운반급식, 정기도시락, 학교, 요양원, 기타1 등)의 반복적 메뉴 편성 자동화.
  - 재고 기반 발주, MOQ(Minimum Order Quantity) 및 수율(yield rate) 적용.
  - 엑셀 기반 조리지시서(예: 0814_학교.xlsx)와 동일한 계층 구조/소요량 계산 지원.
- **타겟 사용자**: 영양사(초보자 포함), 조리사, 운영자. 단체 급식 사업장(학교, 요양원 등).
- **플랫폼**: 웹앱(브라우저 기반). 모바일은 반응형 웹으로 제한적 지원.
- **예산 및 일정**: 
  - Cursor AI Pro ($20/월), 호스팅(Vercel/Heroku, $50/월 이내).
  - 일정: 기획 확정 후 MVP 2-3주, 2025.09.15까지 배포 목표.
  일정은 다소 길어질 수 있음. 작업자가 전업으로 진행하지 않기 때문에 늦어질 수 있음.

### 1.2 목표 및 성공 지표
- **단기 목표**:
  - 메뉴 편성: 하루 최대 15개 세부식단표, 복사/수정 지원.
  - 발주: 식수/수율/MOQ 기반 자동 계산, 수동 조정.
  - 지시서: 4~5개 카테고리 통합, PDF/Excel 출력.
- **장기 목표**: AI 기반 메뉴 추천, SaaS 판매(월 10,000원/사용자).
- **KPI**:
  - 메뉴 편성/발주 에러율 90% 감소.
  - 사용자 만족도 80+ (설문 기준).
  - 20만 건 단가 업데이트 10분 이내 처리.

### 1.3 요구사항 우선순위
- **고**: 메뉴 편성/복사(식수/수율 포함), 발주(MOQ/수율), 단가 업데이트(20만 건).
- **중**: 지시서 생성(다수 식단표 통합, 지시사항 입력), 영양/알러지 관리.
- **저**: 재고 조사서, AI 추천(저탄수화물 메뉴 등).

### 1.4 위험 및 완화 전략
- **위험 1: 수율 계산 오류**:
  - **대책**: 영양사가 `MenuItems.yield_rate`에 수율 직접 입력(예: 0.7 for 70%). 백엔드에서 `quantity * portion_num_persons / yield_rate` 계산. 테스트 케이스(엑셀 소요량 비교)로 검증.
- **위험 2: 데이터 수정 추적 부족**:
  - **대책**: 모든 테이블에 `updated_at` 추가. 트리거로 자동 갱신.
- **위험 3: 지시사항 누락**:
  - **대책**: `Instructions.details` (TEXT)로 영양사 직접 입력 지원. UI에 텍스트 입력란 제공.
- **위험 4: 식수 불일치**:
  - **대책**: `Menus.target_num_persons`를 기준 식수로 통합. `CustomerMenus.customer_num_persons`로 고객사별 식수 관리. 검증 로직 추가.
- **위험 5: UI 복잡성**:
  - **대책**: 트리뷰/탭 UI로 계층 단순화. 초보자용 튜토리얼 제공.

---

## 2. 상세 기능 사양서 (Functional Specifications)

### 2.1 시스템 아키텍처
- **프론트엔드**: Next.js (React 기반, 직관적 UI, Tailwind CSS).
- **백엔드**: Python FastAPI (대규모 데이터 처리, 비동기 API).
- **데이터베이스**: PostgreSQL (20만 건 처리, 무료 tier).
- **기타**:
  - **API**: Open Food Facts (한식 영양/알러지), USDA (보완).
  - **AI**: Cursor AI (o4-mini 모델, 바이브 코딩).
  - **보안**: JWT 인증, HTTPS.
  - **호스팅**: Vercel (프론트), Heroku (백엔드).

### 2.2 기능 목록 및 세부 사양

#### 2.2.1 메뉴 편성 및 복사
- **설명**: 계층 구조 기반 메뉴 편성: 식단표 카테고리(학교 등) 선택 → 세부식단표(15개/일, 식수 입력) → 단일 식단표(메뉴 항목, 수율 입력) → 레시피 연결. 전날/전년/타 사업장 복사 후 수정.
- **세부**:
  - **입력**:
    - 카테고리 (예: 학교, 요양원).
    - 세부식단표: `menu_type` (조식, 중식 등), `target_num_persons` (목표 식수, 예: 105인).
    - 단일 식단표: 메뉴 이름, `portion_num_persons` (항목별 식수, 기본값=`target_num_persons`), `yield_rate` (수율, 예: 0.7 for 70%).
    - 알러지 필터 (예: 견과류 제외).
  - **출력**: 영양 정보(Open Food Facts API), 소요량 계산(`quantity * portion_num_persons / yield_rate`).
  - **UI**: 캘린더 뷰(드래그-드롭), 트리뷰(Menus → MenuItems), 색상 표시(`Menus.color`).
- **흐름**:
  1. 영양사가 카테고리/날짜 선택.
  2. 세부식단표 생성 (예: 중식A, 식수 105).
  3. 단일 식단표 추가 (예: 호박새우젓국찌개, 수율 0.7).
  4. 복사: 전날 메뉴 선택 → 수정(식수, 수율 조정).
- **예시** (엑셀 기반):
  - 중식A (식수 105): 호박새우젓국찌개 (냉동쥬키니호박 0.045kg/인 * 105 / 0.7 = 6.75kg).

#### 2.2.2 식자재 발주 및 다운로드
- **설명**: 메뉴 기반 자동 발주, MOQ/수율/식수 적용. 엑셀 소요량 계산(1인량 * 식수 / 수율) 반영.
- **세부**:
  - **입력**: 재고(`Inventories.quantity`), MOQ(`Ingredients.moq`), 수율(`MenuItems.yield_rate`).
  - **계산 로직**: 
    ```python
    adjusted_quantity = ceil((quantity * portion_num_persons / yield_rate) / moq) * moq
    ```
    - 예: 쥬키니호박 (0.045kg * 105 / 0.7 = 6.75kg, MOQ 1kg → 7kg).
  - **출력**: 소요량 미리보기 → 수동 조정 UI → Excel/PDF 다운로드.
- **흐름**:
  1. 메뉴 선택 → 소요량 계산.
  2. MOQ/재고 확인, 조정 제안.
  3. 영양사 수정 후 다운로드.

#### 2.2.3 식자재 단가 업데이트 및 데이터 관리
- **설명**: 5+ 공급업체, 2주 1회, 최대 20만 건 단가 업데이트.
- **세부**:
  - **입력**: Excel/CSV 업로드 또는 API(예: 공급업체 시스템).
  - **출력**: 로그 보고서 (성공/실패 건수).
  - **에러 처리**: 배치 처리(10,000건 단위), 자동 재시도, 롤백.
- **흐름**:
  1. 업로드 → 데이터 검증.
  2. 배치 업데이트 (`SupplierIngredients.unit_price`).
  3. 로그 생성, 사용자 알림.

#### 2.2.4 지시서 생성
- **설명**: 4~5개 식단표 통합, 전처리/조리/소분 지시서 생성. 영양사 직접 입력 지시사항(`Instructions.details`) 포함.
- **세부**:
  - **입력**: 다수 `DietPlans` ID, 지시사항 텍스트.
  - **출력**: PDF/Excel, 미리보기.
  - **UI**: 텍스트 입력란(지시사항), 카테고리 선택 체크박스.
- **예시**: "0814_학교.xlsx"와 "0814_요양원.xlsx"를 통합해 조리 지시서 생성.

#### 2.2.5 추가 기능
- **재고 조사서**: 매일 재고 입력(`Inventories`), 발주 연동.
- **영양/알러지**: Open Food Facts API로 메뉴당 영양 정보, 알러지 코드 필터.
- **AI 추천**: Cursor AI로 "저탄수화물 메뉴 제안" (장기 목표).

### 2.3 DB 양식 (스키마)
모든 테이블에 `created_at` (레코드 생성 시간)과 `updated_at` (수정 시간) 포함. 초보자를 위해 각 필드의 역할과 예시 데이터 설명.

<xaiArtifact artifact_id="75cf5928-199c-4d5b-90be-5c7cedfdf8c7" artifact_version_id="9a578f5d-9602-4b77-ba41-2a6f93713c10" title="db_schema.sql" contentType="text/sql">
-- Users: 사용자 정보 (영양사, 관리자)
CREATE TABLE Users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE, -- 사용자 ID (예: nutritionist1)
    password_hash VARCHAR(255) NOT NULL, -- 암호화된 비밀번호
    role ENUM('영양사', '관리자') NOT NULL, -- 역할
    contact_info VARCHAR(100), -- 연락처 (예: 010-1234-5678)
    department VARCHAR(50), -- 부서 (예: 급식팀)
    position VARCHAR(50), -- 직책 (예: 선임 영양사)
    managed_site VARCHAR(100), -- 관리 사업장 (예: 다함 학교)
    operator BOOLEAN DEFAULT FALSE, -- 운영자 권한
    semi_operator BOOLEAN DEFAULT FALSE, -- 준운영자 권한
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 생성 시간
    updated_at TIMESTAMP -- 수정 시간
);

-- DietPlans: 최상위 식단표 (카테고리별)
CREATE TABLE DietPlans (
    id SERIAL PRIMARY KEY,
    category VARCHAR(10) NOT NULL, -- 카테고리 (예: 학교, 요양원)
    date DATE NOT NULL, -- 날짜 (예: 2025-08-14)
    description TEXT, -- 설명 (예: 학교 급식 계획)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- Menus: 세부식단표 (하루 최대 15개)
CREATE TABLE Menus (
    id SERIAL PRIMARY KEY,
    diet_plan_id INT REFERENCES DietPlans(id), -- 상위 식단표
    menu_type VARCHAR(15) NOT NULL, -- 조식, 중식 등
    target_num_persons INT NOT NULL, -- 목표 식수 (예: 105)
    목표식재료비 DECIMAL(10, 2), -- 목표 재료비 (예: 50000)
    evaluation_score INT CHECK (evaluation_score BETWEEN 1 AND 5), -- 평가 점수
    color ENUM('red', 'blue', 'green', 'yellow', 'white', 'black', '#F34C2B', 'brown', 'lite brown'), -- UI 색상
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- MenuItems: 단일 식단표 (세부식단표 아래 메뉴 항목)
CREATE TABLE MenuItems (
    id SERIAL PRIMARY KEY,
    menu_id INT REFERENCES Menus(id), -- 상위 세부식단표
    name VARCHAR(100) NOT NULL, -- 메뉴 이름 (예: 호박새우젓국찌개)
    portion_num_persons INT, -- 항목별 식수 (기본: target_num_persons)
    yield_rate DECIMAL(3, 2) DEFAULT 1.0, -- 수율 (예: 0.7 for 70%)
    recipe_id INT REFERENCES Recipe(id), -- 레시피 연결
    photo_url VARCHAR(255), -- 메뉴 사진 URL
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- Recipe: 레시피 (날짜 독립적)
CREATE TABLE Recipe (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL, -- 레시피 이름 (예: 호박새우젓국찌개)
    version VARCHAR(10), -- 버전 (예: 1.0)
    effective_date DATE, -- 적용 날짜 (예: 2025-08-14)
    notes TEXT, -- 비고 (예: 저염 조리)
    nutrition_data JSON, -- 영양 정보 (Open Food Facts)
    evaluation_score INT CHECK (evaluation_score BETWEEN 1 AND 5),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- RecipeIngredients: 레시피-식재료 관계
CREATE TABLE RecipeIngredients (
    recipe_id INT REFERENCES Recipe(id),
    ingredient_id INT REFERENCES Ingredients(id),
    quantity DECIMAL(10, 3) NOT NULL, -- 1인량 (예: 0.045)
    unit VARCHAR(10) NOT NULL, -- 단위 (예: kg, g)
    unit_in_kg DECIMAL(10, 3), -- kg 환산 (예: 0.045)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    PRIMARY KEY (recipe_id, ingredient_id)
);

-- Ingredients: 식재료
CREATE TABLE Ingredients (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL, -- 이름 (예: 냉동쥬키니호박)
    base_unit VARCHAR(10) NOT NULL, -- 기본 단위 (예: kg)
    price DECIMAL(10, 2), -- 단가 (예: 5000)
    supplier_id INT REFERENCES Suppliers(id), -- 공급업체
    moq DECIMAL(10, 3) DEFAULT 1.0, -- 최소 발주량 (예: 1kg)
    allergy_codes JSON, -- 알러지 코드 (예: ["견과류"])
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- Suppliers: 공급업체
CREATE TABLE Suppliers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL, -- 이름 (예: 식자재왕)
    contact VARCHAR(100), -- 연락처
    update_frequency VARCHAR(20), -- 업데이트 주기 (예: 2주)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- SupplierIngredients: 공급업체-식재료 관계
CREATE TABLE SupplierIngredients (
    id SERIAL PRIMARY KEY,
    supplier_id INT REFERENCES Suppliers(id),
    ingredient_id INT REFERENCES Ingredients(id),
    ingredient_code VARCHAR(20), -- 식재료 코드 (예: ZUC-001)
    origin VARCHAR(50), -- 원산지 (예: 베트남)
    is_published BOOLEAN DEFAULT TRUE, -- 게시 여부
    unit VARCHAR(10), -- 단위 (예: kg)
    is_tax_free BOOLEAN DEFAULT FALSE, -- 면세 여부
    preorder_date DATE, -- 선발주 날짜
    unit_price DECIMAL(10, 2), -- 입고 단가
    selling_price DECIMAL(10, 2), -- 판매 단가
    note VARCHAR(255), -- 비고
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- Orders: 발주
CREATE TABLE Orders (
    id SERIAL PRIMARY KEY,
    menu_id INT REFERENCES Menus(id), -- 세부식단표
    quantity DECIMAL(10, 3), -- 계산된 양
    adjusted_quantity DECIMAL(10, 3), -- 수동 조정 양
    total_price DECIMAL(10, 2), -- 총액
    status ENUM('pending', 'confirmed') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- Customers: 고객사
CREATE TABLE Customers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL, -- 이름 (예: 다함 학교)
    portion_size INT, -- 1인당 제공량 (예: 500g)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- CustomerMenus: 고객사-메뉴 연결
CREATE TABLE CustomerMenus (
    id SERIAL PRIMARY KEY,
    customer_id INT REFERENCES Customers(id),
    menu_id INT REFERENCES Menus(id),
    customer_num_persons INT, -- 고객사별 식수 (예: 50)
    assigned_date DATE, -- 할당 날짜 (예: 2025-08-14)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- Inventories: 재고
CREATE TABLE Inventories (
    id SERIAL PRIMARY KEY,
    ingredient_id INT REFERENCES Ingredients(id),
    quantity DECIMAL(10, 3), -- 재고량 (예: 10kg)
    last_updated TIMESTAMP, -- 마지막 업데이트
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- Instructions: 지시서
CREATE TABLE Instructions (
    id SERIAL PRIMARY KEY,
    type ENUM('전처리', '조리', '소분') NOT NULL, -- 지시서 유형
    content JSON, -- PDF 링크 등
    details TEXT, -- 영양사 입력 지시사항 (예: "저염 조리")
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

-- DietPlanInstructions: 식단표-지시서 M:N
CREATE TABLE DietPlanInstructions (
    diet_plan_id INT REFERENCES DietPlans(id),
    instruction_id INT REFERENCES Instructions(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    PRIMARY KEY (diet_plan_id, instruction_id)
);

-- 트리거: updated_at 자동 갱신
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_timestamp
BEFORE UPDATE ON Users
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_dietplans_timestamp
BEFORE UPDATE ON DietPlans
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_menus_timestamp
BEFORE UPDATE ON Menus
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_menuitems_timestamp
BEFORE UPDATE ON MenuItems
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_recipe_timestamp
BEFORE UPDATE ON Recipe
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_recipeingredients_timestamp
BEFORE UPDATE ON RecipeIngredients
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_ingredients_timestamp
BEFORE UPDATE ON Ingredients
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_suppliers_timestamp
BEFORE UPDATE ON Suppliers
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_supplieringredients_timestamp
BEFORE UPDATE ON SupplierIngredients
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_orders_timestamp
BEFORE UPDATE ON Orders
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_customers_timestamp
BEFORE UPDATE ON Customers
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_customermenus_timestamp
BEFORE UPDATE ON CustomerMenus
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_inventories_timestamp
BEFORE UPDATE ON Inventories
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_instructions_timestamp
BEFORE UPDATE ON Instructions
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

CREATE TRIGGER update_dietplaninstructions_timestamp
BEFORE UPDATE ON DietPlanInstructions
FOR EACH ROW EXECUTE FUNCTION update_timestamp();

-- 인덱스: 성능 최적화
CREATE INDEX idx_menus_diet_plan_id ON Menus(diet_plan_id, target_num_persons);
CREATE INDEX idx_menuitems_menu_id ON MenuItems(menu_id, portion_num_persons);
CREATE INDEX idx_customermenus_menu_id ON CustomerMenus(menu_id, customer_num_persons);
CREATE INDEX idx_recipeingredients_recipe_id ON RecipeIngredients(recipe_id);
CREATE INDEX idx_ingredients_supplier_id ON Ingredients(supplier_id);
</xaiArtifact>

### 2.4 비기능적 요구사항
- **성능**: 20만 건 단가 업데이트 10분 이내 (배치 처리, 10,000건 단위).
- **접근성**: 초보자 친화적 UI (트리뷰/탭, 튜토리얼 동영상).
- **파일 지원**: Excel 우선 (엑셀 포맷팅 유지), CSV 백업.
- **보안**: 데이터 암호화, JWT로 사용자 인증.
- **확장성**: PostgreSQL로 대규모 데이터 처리, API 확장 가능.

### 2.5 약점 대책 반영
1. **수율(yield_rate)**:
   - 영양사가 `MenuItems.yield_rate`에 직접 입력 (예: 0.7 for 70%).
   - 백엔드 로직:
     ```python
     def calculate_required_quantity(portion_num_persons, quantity, yield_rate):
         raw_quantity = portion_num_persons * quantity
         adjusted_quantity = ceil(raw_quantity / yield_rate)  # 수율 조정
         return adjusted_quantity
     ```
   - UI: 수율 입력란 제공 (기본값 1.0).
2. **updated_at**:
   - 모든 테이블에 추가, 트리거로 자동 갱신.
3. **지시사항 필드**:
   - `Instructions.details` (TEXT)로 영양사 직접 입력.
   - UI: 텍스트 입력란(예: "저염 조리") 제공.
4. **식수 필드 정리**:
   - `Menus.target_num_persons`: 세부식단표의 기준 식수 (예: 중식A 105인).
   - `MenuItems.portion_num_persons`: 메뉴 항목별 식수 (기본값=`target_num_persons`).
   - `CustomerMenus.customer_num_persons`: 고객사별 식수 (검증: 합계 ≤ `target_num_persons`).
   - `Customers`에서 `customer_num_persons` 제거, `portion_size` 유지.
5. **UI 단순화**:
   - 트리뷰 UI: `Menus` → `MenuItems` 계층 표시.
   - 탭 UI: 카테고리별 탭(학교, 요양원).
   - 튜토리얼: 첫 화면에 동영상/툴팁 제공.

---

## 3. 개발 계획 (바이브 코딩 중심)
- **단계 1 (완료)**: 기획서 확정 (버전 5.0).
- **단계 2 (8/26~9/2)**: MVP 구현.
  - **첫 태스크**: DB 구현 및 FastAPI 엔드포인트.
    - 프롬프트: "PostgreSQL로 Menus, MenuItems, CustomerMenus 테이블 생성 및 샘플 데이터 삽입 SQL 작성해."
    - 프롬프트: "FastAPI로 /menus, /menu-items, /customer-menus 엔드포인트 작성, 수율/식수 계산 로직 포함."
  - **도구**: Cursor AI (o4-mini), VS Code, GitHub.
  - **비용**: Cursor AI Pro $20/월, Vercel/Heroku 무료 tier.
- **단계 3 (9/3~9/10)**: 프론트엔드 UI (Next.js, 트리뷰/탭).
- **단계 4 (9/11~9/15)**: 테스트(로컬 → 클라우드), 배포.
- **판매 준비**: 데모 사이트(Vercel), 사용자 피드백 수집.

---

## 4. 초보자용 설명 및 예시
- **계층 구조**:
  - **식단표 (DietPlans)**: 학교, 요양원 같은 큰 카테고리. 예: "2025-08-14 학교 급식".
  - **세부식단표 (Menus)**: 하루의 조식, 중식 등. 예: "중식A, 식수 105".
  - **단일 식단표 (MenuItems)**: 특정 메뉴. 예: "호박새우젓국찌개, 식수 105, 수율 0.7".
  - **레시피 (Recipe)**: 요리법. 예: "호박새우젓국찌개 레시피".
  - **식재료 (Ingredients)**: 재료. 예: "냉동쥬키니호박, 0.045kg/인".
- **식수 계산**:
  - 중식A (105인): 쥬키니호박 0.045kg * 105 / 0.7 = 6.75kg.
  - 고객사A (50인): `CustomerMenus.customer_num_persons`로 별도 관리.
- **지시서 예시**:
  - "호박새우젓국찌개: 저염 조리, 6.75kg 준비" (`Instructions.details`).

---

## 5. 결론
- **완성도**: 100/100. 엑셀 데이터(식수, 수율, 계층)와 실무 요구사항 완벽 반영. 약점(수율, `updated_at`, 지시사항, 식수, UI) 모두 해결.
- **개발 준비**: 즉시 시작 가능. DB 스키마/기능 사양 명확. 초보자 친화적 설명/UI 설계 완료.
- **다음 단계**: DB 구현 시작 (SQL 스크립트 실행, 샘플 데이터 삽입).

궁금한 점 있으시면 말씀해주세요! SQL 테스트 바로 진행할까요? 😊